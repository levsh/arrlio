{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Arrlio - distributed task system.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#arrlio.core","title":"<code>arrlio.core</code>","text":""},{"location":"api_reference/#arrlio.core.App","title":"<code>App</code>","text":"<p>Arrlio application.</p> Source code in <code>arrlio/core.py</code> <pre><code>class App:\n    \"\"\"Arrlio application.\"\"\"\n\n    def __init__(self, config: Config):\n        \"\"\"\n        Args:\n            config: Arrlio application `arrlio.settings.Config`.\n        \"\"\"\n\n        self.config = config\n\n        self._backend = config.backend.module.Backend(config.backend.config)\n        self._closed: asyncio.Future = asyncio.Future()\n        self._running_tasks: dict[UUID, asyncio.Task] = {}\n        self._executor = config.executor.module.Executor(config.executor.config)\n        self._context = ContextVar(\"context\", default={})\n\n        self._hooks = {\n            \"on_init\": [],\n            \"on_close\": [],\n            \"on_task_send\": [],\n            \"on_task_received\": [],\n            \"on_task_result\": [],\n            \"on_task_done\": [],\n            \"task_context\": [],\n        }\n\n        self._plugins = {}\n        for plugin_config in config.plugins:\n            plugin = plugin_config.module.Plugin(self, plugin_config.config)\n            self._plugins[plugin.name] = plugin\n            for k, hooks in self._hooks.items():\n                if getattr(plugin, k).__func__ != getattr(Plugin, k):\n                    hooks.append(getattr(plugin, k))\n\n        self._task_settings = {\n            k: v for k, v in config.task.model_dump(exclude_unset=True).items() if k in dataclasses.fields(Task)\n        }\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}[{self._backend}]\"\n\n    def __repr__(self):\n        return self.__str__()\n\n    async def __aenter__(self):\n        await self.init()\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self.close()\n\n    @property\n    def hooks(self):\n        return rodict(self._hooks, nested=True)\n\n    @property\n    def plugins(self) -&gt; dict[str, Plugin]:\n        \"\"\"Application plugins.\"\"\"\n\n        return rodict(self._plugins, nested=True)\n\n    @property\n    def backend(self) -&gt; Backend:\n        \"\"\"Application backend.\"\"\"\n\n        return self._backend\n\n    @property\n    def executor(self) -&gt; Executor:\n        \"\"\"Application executor.\"\"\"\n\n        return self._executor\n\n    @property\n    def context(self):\n        return self._context\n\n    @property\n    def is_closed(self) -&gt; bool:\n        return self._closed.done()\n\n    @property\n    def task_settings(self) -&gt; dict:\n        return self._task_settings\n\n    async def init(self):\n        \"\"\"Init application and plugins.\"\"\"\n\n        if self.is_closed:\n            return\n\n        logger.info(\"%s: initializing with config\\n%s\", self, pretty_repr(self.config.model_dump()))\n\n        await self._execute_hooks(\"on_init\")\n\n        logger.info(\"%s: initialization done\", self)\n\n    async def close(self):\n        \"\"\"Close application.\"\"\"\n\n        if self.is_closed:\n            return\n\n        try:\n            await self._execute_hooks(\"on_close\")\n            for hooks in self._hooks.values():\n                hooks.clear()\n\n            await gather(\n                self.stop_consume_tasks(),\n                self.stop_consume_events(),\n                return_exceptions=True,\n            )\n\n            await self._backend.close()\n\n            for task_id, aio_task in tuple(self._running_tasks.items()):\n                logger.warning(\"%s: cancel processing task '%s'\", self, task_id)\n                aio_task.cancel()\n                try:\n                    await aio_task\n                except asyncio.CancelledError:\n                    pass\n            self._running_tasks = {}\n\n        finally:\n            self._closed.set_result(None)\n\n    async def _execute_hook(self, hook_fn, *args, **kwds):\n        try:\n            if is_debug_level():\n                logger.debug(\"%s: execute hook %s\", self, hook_fn)\n            await hook_fn(*args, **kwds)\n        except Exception:\n            logger.exception(\"%s: hook %s error\", self, hook_fn)\n\n    async def _execute_hooks(self, hook: str, *args, **kwds):\n        await gather(*(self._execute_hook(hook_fn, *args, **kwds) for hook_fn in self._hooks[hook]))\n\n    async def send_task(\n        self,\n        task: Task | str,  # pylint: disable=redefined-outer-name\n        args: Args | None = None,\n        kwds: Kwds | None = None,\n        extra: dict | None = None,\n        **kwargs: dict,\n    ) -&gt; \"AsyncResult\":\n        \"\"\"Send task.\n\n        Args:\n            task: `arrlio.models.Task` or task name.\n            args: Task args.\n            kwds: Task kwds.\n            extra: `arrlio.models.Task` extra argument.\n            kwargs: Other `arrlio.models.Task` other arguments.\n\n        Returns:\n            Task `arrlio.core.AsyncResult`.\n        \"\"\"\n\n        name = task\n        if isinstance(task, Task):\n            name = task.name\n\n        if extra is None:\n            extra = {}\n\n        extra[\"app_id\"] = self.config.app_id\n\n        if name in registered_tasks:\n            task_instance = registered_tasks[name].instantiate(\n                args=args,\n                kwds=kwds,\n                extra=extra,\n                **{**self._task_settings, **kwargs},\n            )\n        else:\n            task_instance = Task(None, name).instantiate(\n                args=args,\n                kwds=kwds,\n                extra=extra,\n                **{**self._task_settings, **kwargs},\n            )\n\n        if is_info_level():\n            logger.info(\n                \"%s: send task instance\\n%s\",\n                self,\n                task_instance.pretty_repr(sanitize=settings.LOG_SANITIZE),\n            )\n\n        await self._execute_hooks(\"on_task_send\", task_instance)\n\n        await self._backend.send_task(task_instance)\n\n        return AsyncResult(self, task_instance)\n\n    async def send_event(self, event: Event):\n        if is_info_level():\n            logger.info(\"%s: send event\\n%s\", self, event.pretty_repr(sanitize=settings.LOG_SANITIZE))\n\n        await self._backend.send_event(event)\n\n    async def pop_result(self, task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]:\n        async for task_result in self._backend.pop_task_result(task_instance):\n            if is_info_level():\n                logger.info(\n                    \"%s got result[idx=%s, exc=%s] for task %s[%s]\",\n                    self,\n                    task_result.idx,\n                    task_result.exc is not None,\n                    task_instance.name,\n                    task_instance.task_id,\n                )\n            if task_result.exc:\n                if isinstance(task_result.exc, TaskError):\n                    if task_result.exc.task_id is None:\n                        task_result.exc.task_id = task_instance.task_id\n                    raise task_result.exc\n                raise TaskError(task_instance.task_id, task_result.exc, task_result.trb)\n\n            yield task_result.res\n\n    async def consume_tasks(self, queues: list[str] | None = None):\n        \"\"\"Consume tasks from the queues.\"\"\"\n\n        queues = queues or self.config.task_queues\n        if not queues:\n            return\n\n        async def cb(task_instance: TaskInstance):\n            task_id: UUID = task_instance.task_id\n\n            self._running_tasks[task_id] = current_task()\n            try:\n                async with AsyncExitStack() as stack:\n                    for context in self._hooks[\"task_context\"]:\n                        await stack.enter_async_context(context(task_instance))\n\n                    await self._execute_hooks(\"on_task_received\", task_instance)\n\n                    task_result: TaskResult = TaskResult()\n\n                    idx_0 = uuid4().hex\n                    idx_1 = 0\n\n                    async for task_result in self.execute_task(task_instance):\n                        idx_1 += 1\n                        task_result.set_idx([idx_0, idx_1])\n\n                        if task_instance.result_return:\n                            await self._backend.push_task_result(task_result, task_instance)\n\n                        await self._execute_hooks(\"on_task_result\", task_instance, task_result)\n\n                    if task_instance.result_return and not task_instance.extra.get(\"graph:graph\"):\n                        func = task_instance.func\n                        if isasyncgenfunction(func) or isgeneratorfunction(func):\n                            idx_1 += 1\n                            await self._backend.close_task(task_instance, idx=(idx_0, idx_1))\n\n                    await self._execute_hooks(\"on_task_done\", task_instance, task_result)\n\n            except asyncio.CancelledError:\n                logger.error(\"%s: task %s(%s) cancelled\", self, task_id, task_instance.name)\n                raise\n            except Exception as e:\n                logger.exception(e)\n            finally:\n                self._running_tasks.pop(task_id, None)\n\n        await self._backend.consume_tasks(queues, cb)\n        logger.info(\"%s: consuming task queues %s\", self, queues)\n\n    async def stop_consume_tasks(self, queues: list[str] | None = None):\n        \"\"\"Stop consuming tasks.\"\"\"\n\n        await self._backend.stop_consume_tasks(queues=queues)\n        if queues is not None:\n            logger.info(\"%s: stop consuming task queues %s\", self, queues)\n        else:\n            logger.info(\"%s: stop consuming task queues\", self)\n\n    async def execute_task(self, task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]:\n        \"\"\"Execute the task instance locally by the application executor.\"\"\"\n\n        async for task_result in self._executor(task_instance):\n            yield task_result\n\n    async def consume_events(\n        self,\n        callback_id: str,\n        callback: Callable[[Event], Any],\n        event_types: list[str] | None = None,\n    ):\n        \"\"\"Consume events.\"\"\"\n\n        await self._backend.consume_events(callback_id, callback, event_types=event_types)\n\n    async def stop_consume_events(self, callback_id: str | None = None):\n        \"\"\"Stop consuming events.\"\"\"\n\n        await self._backend.stop_consume_events(callback_id=callback_id)\n\n    def send_graph(self, *args, **kwds):\n        if \"arrlio.graphs\" not in self.plugins:\n            raise GraphError(\"Plugin required: allrio.graphs\")\n        return self.plugins[\"arrlio.graphs\"].send_graph(*args, **kwds)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.plugins","title":"<code>plugins: dict[str, Plugin]</code>  <code>property</code>","text":"<p>Application plugins.</p>"},{"location":"api_reference/#arrlio.core.App.backend","title":"<code>backend: Backend</code>  <code>property</code>","text":"<p>Application backend.</p>"},{"location":"api_reference/#arrlio.core.App.executor","title":"<code>executor: Executor</code>  <code>property</code>","text":"<p>Application executor.</p>"},{"location":"api_reference/#arrlio.core.App.__init__","title":"<code>__init__(config: Config)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Arrlio application <code>arrlio.settings.Config</code>.</p> required Source code in <code>arrlio/core.py</code> <pre><code>def __init__(self, config: Config):\n    \"\"\"\n    Args:\n        config: Arrlio application `arrlio.settings.Config`.\n    \"\"\"\n\n    self.config = config\n\n    self._backend = config.backend.module.Backend(config.backend.config)\n    self._closed: asyncio.Future = asyncio.Future()\n    self._running_tasks: dict[UUID, asyncio.Task] = {}\n    self._executor = config.executor.module.Executor(config.executor.config)\n    self._context = ContextVar(\"context\", default={})\n\n    self._hooks = {\n        \"on_init\": [],\n        \"on_close\": [],\n        \"on_task_send\": [],\n        \"on_task_received\": [],\n        \"on_task_result\": [],\n        \"on_task_done\": [],\n        \"task_context\": [],\n    }\n\n    self._plugins = {}\n    for plugin_config in config.plugins:\n        plugin = plugin_config.module.Plugin(self, plugin_config.config)\n        self._plugins[plugin.name] = plugin\n        for k, hooks in self._hooks.items():\n            if getattr(plugin, k).__func__ != getattr(Plugin, k):\n                hooks.append(getattr(plugin, k))\n\n    self._task_settings = {\n        k: v for k, v in config.task.model_dump(exclude_unset=True).items() if k in dataclasses.fields(Task)\n    }\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.init","title":"<code>init()</code>  <code>async</code>","text":"<p>Init application and plugins.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def init(self):\n    \"\"\"Init application and plugins.\"\"\"\n\n    if self.is_closed:\n        return\n\n    logger.info(\"%s: initializing with config\\n%s\", self, pretty_repr(self.config.model_dump()))\n\n    await self._execute_hooks(\"on_init\")\n\n    logger.info(\"%s: initialization done\", self)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close application.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def close(self):\n    \"\"\"Close application.\"\"\"\n\n    if self.is_closed:\n        return\n\n    try:\n        await self._execute_hooks(\"on_close\")\n        for hooks in self._hooks.values():\n            hooks.clear()\n\n        await gather(\n            self.stop_consume_tasks(),\n            self.stop_consume_events(),\n            return_exceptions=True,\n        )\n\n        await self._backend.close()\n\n        for task_id, aio_task in tuple(self._running_tasks.items()):\n            logger.warning(\"%s: cancel processing task '%s'\", self, task_id)\n            aio_task.cancel()\n            try:\n                await aio_task\n            except asyncio.CancelledError:\n                pass\n        self._running_tasks = {}\n\n    finally:\n        self._closed.set_result(None)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.send_task","title":"<code>send_task(task: Task | str, args: Args | None = None, kwds: Kwds | None = None, extra: dict | None = None, **kwargs: dict) -&gt; AsyncResult</code>  <code>async</code>","text":"<p>Send task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task | str</code> <p><code>arrlio.models.Task</code> or task name.</p> required <code>args</code> <code>Args | None</code> <p>Task args.</p> <code>None</code> <code>kwds</code> <code>Kwds | None</code> <p>Task kwds.</p> <code>None</code> <code>extra</code> <code>dict | None</code> <p><code>arrlio.models.Task</code> extra argument.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>Other <code>arrlio.models.Task</code> other arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncResult</code> <p>Task <code>arrlio.core.AsyncResult</code>.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def send_task(\n    self,\n    task: Task | str,  # pylint: disable=redefined-outer-name\n    args: Args | None = None,\n    kwds: Kwds | None = None,\n    extra: dict | None = None,\n    **kwargs: dict,\n) -&gt; \"AsyncResult\":\n    \"\"\"Send task.\n\n    Args:\n        task: `arrlio.models.Task` or task name.\n        args: Task args.\n        kwds: Task kwds.\n        extra: `arrlio.models.Task` extra argument.\n        kwargs: Other `arrlio.models.Task` other arguments.\n\n    Returns:\n        Task `arrlio.core.AsyncResult`.\n    \"\"\"\n\n    name = task\n    if isinstance(task, Task):\n        name = task.name\n\n    if extra is None:\n        extra = {}\n\n    extra[\"app_id\"] = self.config.app_id\n\n    if name in registered_tasks:\n        task_instance = registered_tasks[name].instantiate(\n            args=args,\n            kwds=kwds,\n            extra=extra,\n            **{**self._task_settings, **kwargs},\n        )\n    else:\n        task_instance = Task(None, name).instantiate(\n            args=args,\n            kwds=kwds,\n            extra=extra,\n            **{**self._task_settings, **kwargs},\n        )\n\n    if is_info_level():\n        logger.info(\n            \"%s: send task instance\\n%s\",\n            self,\n            task_instance.pretty_repr(sanitize=settings.LOG_SANITIZE),\n        )\n\n    await self._execute_hooks(\"on_task_send\", task_instance)\n\n    await self._backend.send_task(task_instance)\n\n    return AsyncResult(self, task_instance)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.consume_tasks","title":"<code>consume_tasks(queues: list[str] | None = None)</code>  <code>async</code>","text":"<p>Consume tasks from the queues.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def consume_tasks(self, queues: list[str] | None = None):\n    \"\"\"Consume tasks from the queues.\"\"\"\n\n    queues = queues or self.config.task_queues\n    if not queues:\n        return\n\n    async def cb(task_instance: TaskInstance):\n        task_id: UUID = task_instance.task_id\n\n        self._running_tasks[task_id] = current_task()\n        try:\n            async with AsyncExitStack() as stack:\n                for context in self._hooks[\"task_context\"]:\n                    await stack.enter_async_context(context(task_instance))\n\n                await self._execute_hooks(\"on_task_received\", task_instance)\n\n                task_result: TaskResult = TaskResult()\n\n                idx_0 = uuid4().hex\n                idx_1 = 0\n\n                async for task_result in self.execute_task(task_instance):\n                    idx_1 += 1\n                    task_result.set_idx([idx_0, idx_1])\n\n                    if task_instance.result_return:\n                        await self._backend.push_task_result(task_result, task_instance)\n\n                    await self._execute_hooks(\"on_task_result\", task_instance, task_result)\n\n                if task_instance.result_return and not task_instance.extra.get(\"graph:graph\"):\n                    func = task_instance.func\n                    if isasyncgenfunction(func) or isgeneratorfunction(func):\n                        idx_1 += 1\n                        await self._backend.close_task(task_instance, idx=(idx_0, idx_1))\n\n                await self._execute_hooks(\"on_task_done\", task_instance, task_result)\n\n        except asyncio.CancelledError:\n            logger.error(\"%s: task %s(%s) cancelled\", self, task_id, task_instance.name)\n            raise\n        except Exception as e:\n            logger.exception(e)\n        finally:\n            self._running_tasks.pop(task_id, None)\n\n    await self._backend.consume_tasks(queues, cb)\n    logger.info(\"%s: consuming task queues %s\", self, queues)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.stop_consume_tasks","title":"<code>stop_consume_tasks(queues: list[str] | None = None)</code>  <code>async</code>","text":"<p>Stop consuming tasks.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def stop_consume_tasks(self, queues: list[str] | None = None):\n    \"\"\"Stop consuming tasks.\"\"\"\n\n    await self._backend.stop_consume_tasks(queues=queues)\n    if queues is not None:\n        logger.info(\"%s: stop consuming task queues %s\", self, queues)\n    else:\n        logger.info(\"%s: stop consuming task queues\", self)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.execute_task","title":"<code>execute_task(task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]</code>  <code>async</code>","text":"<p>Execute the task instance locally by the application executor.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def execute_task(self, task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]:\n    \"\"\"Execute the task instance locally by the application executor.\"\"\"\n\n    async for task_result in self._executor(task_instance):\n        yield task_result\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.consume_events","title":"<code>consume_events(callback_id: str, callback: Callable[[Event], Any], event_types: list[str] | None = None)</code>  <code>async</code>","text":"<p>Consume events.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def consume_events(\n    self,\n    callback_id: str,\n    callback: Callable[[Event], Any],\n    event_types: list[str] | None = None,\n):\n    \"\"\"Consume events.\"\"\"\n\n    await self._backend.consume_events(callback_id, callback, event_types=event_types)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.stop_consume_events","title":"<code>stop_consume_events(callback_id: str | None = None)</code>  <code>async</code>","text":"<p>Stop consuming events.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def stop_consume_events(self, callback_id: str | None = None):\n    \"\"\"Stop consuming events.\"\"\"\n\n    await self._backend.stop_consume_events(callback_id=callback_id)\n</code></pre>"},{"location":"api_reference/#arrlio.core.AsyncResult","title":"<code>AsyncResult</code>","text":"Source code in <code>arrlio/core.py</code> <pre><code>class AsyncResult:\n    __slots__ = (\"_app\", \"_task_instance\", \"_gen\", \"_result\", \"_exception\", \"_ready\")\n\n    def __init__(self, app: App, task_instance: TaskInstance):\n        self._app = app\n        self._task_instance = task_instance\n        self._gen = app.pop_result(task_instance)\n        self._result = None\n        self._exception = None\n        self._ready = False\n\n    @property\n    def task_instance(self) -&gt; TaskInstance:\n        \"\"\"Task instance.\"\"\"\n        return self._task_instance\n\n    @property\n    def task_id(self):\n        \"\"\"Task Id.\"\"\"\n        return self._task_instance.task_id\n\n    @property\n    def result(self):\n        \"\"\"Task last result.\"\"\"\n        return self._result\n\n    @property\n    def exception(self) -&gt; Exception:\n        \"\"\"Task exception.\"\"\"\n        return self._exception\n\n    @property\n    def ready(self) -&gt; bool:\n        \"\"\"Task ready status.\"\"\"\n        return self._ready\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        if not self._ready:\n            try:\n                self._result = await self._gen.__anext__()\n                return self._result\n            except TaskError as e:\n                self._ready = True\n                self._exception = e\n            except StopAsyncIteration as e:\n                self._ready = True\n                raise e\n\n        if exception := self._exception:\n            if isinstance(exception.args[0], Exception):\n                raise exception from exception.args[0]\n            raise exception\n\n        raise StopAsyncIteration\n\n    async def get(self) -&gt; Any:\n        \"\"\"\n        Get task result. Blocking until the task result available.\n        For generator or asyncgenerator return the last available result.\n        \"\"\"\n\n        noresult = not self._ready\n        async for _ in self:\n            noresult = False\n        if noresult:\n            raise TaskClosedError(self.task_id)\n        return self._result\n</code></pre>"},{"location":"api_reference/#arrlio.core.AsyncResult.task_instance","title":"<code>task_instance: TaskInstance</code>  <code>property</code>","text":"<p>Task instance.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.task_id","title":"<code>task_id</code>  <code>property</code>","text":"<p>Task Id.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.result","title":"<code>result</code>  <code>property</code>","text":"<p>Task last result.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.exception","title":"<code>exception: Exception</code>  <code>property</code>","text":"<p>Task exception.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.ready","title":"<code>ready: bool</code>  <code>property</code>","text":"<p>Task ready status.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.get","title":"<code>get() -&gt; Any</code>  <code>async</code>","text":"<p>Get task result. Blocking until the task result available. For generator or asyncgenerator return the last available result.</p> Source code in <code>arrlio/core.py</code> <pre><code>async def get(self) -&gt; Any:\n    \"\"\"\n    Get task result. Blocking until the task result available.\n    For generator or asyncgenerator return the last available result.\n    \"\"\"\n\n    noresult = not self._ready\n    async for _ in self:\n        noresult = False\n    if noresult:\n        raise TaskClosedError(self.task_id)\n    return self._result\n</code></pre>"},{"location":"api_reference/#arrlio.core.task","title":"<code>task(func: FunctionType | MethodType | Type | None = None, name: str | None = None, base: Type[Task] | None = None, **kwds: dict)</code>","text":"<p>Task decorator.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>FunctionType | MethodType | Type | None</code> <p>Task function.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Task name.</p> <code>None</code> <code>base</code> <code>Type[Task] | None</code> <p>Task base class.</p> <code>None</code> <code>kwds</code> <code>dict</code> <p><code>arrlio.models.Task</code> arguments.</p> <code>{}</code> Source code in <code>arrlio/core.py</code> <pre><code>def task(\n    func: FunctionType | MethodType | Type | None = None,\n    name: str | None = None,\n    base: Type[Task] | None = None,\n    **kwds: dict,\n):\n    \"\"\"Task decorator.\n\n    Args:\n        func: Task function.\n        name: Task name.\n        base: Task base class.\n        kwds: `arrlio.models.Task` arguments.\n    \"\"\"\n\n    if base is None:\n        base = Task\n    if func is not None:\n        if not isinstance(func, (FunctionType, MethodType)):\n            raise TypeError(\"Argument 'func' does not a function or method\")\n        if name is None:\n            name = f\"{func.__module__}.{func.__name__}\"\n        if name in registered_tasks:\n            raise ValueError(f\"Task '{name}' already registered\")\n        t = base(func=func, name=name, **kwds)\n        registered_tasks.__original__[name] = t\n        logger.debug(\"Register task '%s'\", t.name)\n        return t\n\n    def wrapper(func):\n        return task(base=base, func=func, name=name, **kwds)\n\n    return wrapper\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install arrlio\n</code></pre>"},{"location":"user_guide/backends/","title":"Backends","text":"<p>Arrlio has several builtin backends:</p> <ul> <li>arrlio.backends.local</li> <li>arrlio.backends.rabbitmq</li> </ul>"},{"location":"user_guide/backends/#local","title":"Local","text":""},{"location":"user_guide/backends/#settings","title":"Settings","text":"<p>All environment varialbles should starts with <code>${ARRLIO_ENV_PREFIX}LOCAL_BACKEND_</code>.</p> <p>Info</p> <p>Default value for <code>ARRLIO_ENV_PREFIX</code> is <code>ARRLIO_</code>.</p> <ul> <li><code>ID</code> (Config.id), default: <code>\"arrlio\"</code>. Backend Id.</li> <li><code>SERIALIZER</code> (Config.serializer), default: <code>\"arrlio.serializers.nop\"</code>. Serializer module with <code>Serializer</code> and <code>Config</code> classes.</li> </ul>"},{"location":"user_guide/backends/#rabbitmq","title":"RabbitMQ","text":""},{"location":"user_guide/backends/#settings_1","title":"Settings","text":"<p>All environment varialbles should starts with <code>${ARRLIO_ENV_PREFIX}RMQ_BACKEND_</code>.</p> <ul> <li><code>ID</code> (Config.id), default: <code>uuid4()</code>. Backend Id.</li> <li><code>SERIALIZER</code> (Config.serializer), default: \"arrlio.serializers.json\". Serializer module with <code>Serializer</code> and <code>Config</code> classes.</li> <li><code>URL</code> (Config.url), default: <code>\"amqp://guest:guest@localhost\"</code>. RabbitMQ server url.</li> <li><code>VERIFY_SSL</code> (Config.verify_ssl), default: <code>True</code>.</li> <li><code>TIMEOUT</code> (Config.timeout), default: <code>10</code>. RabbitMQ operation timeout, seconds.</li> <li><code>PUSH_RETRY_TIMEOUTS</code> (Config.push_retry_timeouts), default: <code>[5, 5, 5, 5, 5]</code>. Retry timeout sequense for push operations, seconds.</li> <li> <p><code>PULL_RETRY_TIMEOUTS</code> (Config.pull_retry_timeouts), default: <code>itertools.repeat(5)</code>. Retry timeout sequense for pull operations, seconds.</p> </li> <li> <p><code>TASKS_EXCHANGE</code> (Config.tasks_exchange), default: <code>\"arrlio\"</code>. Tasks RabbitMQ exchange.</p> </li> <li><code>TASKS_EXCHANGE_DURABLE</code> (Config.tasks_exchange_durable), default: <code>False</code>.</li> <li><code>TASKS_QUEUE_TYPE</code> (Config.tasks_queue_type), default: <code>QueueType.CLASSIC</code>.</li> <li><code>TASKS_QUEUE_DURABLE</code> (Config.tasks_queue_durable), default: <code>False</code>.</li> <li><code>TASKS_QUEUE_AUTO_DELETE</code> (Config.tasks_queue_auto_delete), default: <code>True</code>.</li> <li><code>TASKS_QUEUE_TTL</code> (Config.tasks_queue_ttl), default: <code>None</code>. <code>x-message-ttl</code> RabbitMQ option, seconds.</li> <li> <p><code>TASKS_PREFETCH_COUNT</code> (Config.tasks_prefetch_count), default: <code>1</code>. RabbitMQ prefetch count options.</p> </li> <li> <p><code>EVENTS_EXCHANGE</code> (Config.events_exchange), default: <code>\"arrlio.events\"</code>. Events RabbitMQ exchange.</p> </li> <li><code>EVENTS_EXCHANGE_DURABLE</code> (Config.events_exchange_durable), default: <code>False</code>.</li> <li><code>EVENTS_QUEUE_TYPE</code> (Config.events_queue_type), default: <code>QueueType.CLASSIC</code>.</li> <li><code>EVENTS_QUEUE_DURABLE</code>, (Config.events_queue_durable), default: <code>False</code>.</li> <li><code>EVENTS_QUEUE_AUTO_DELETE</code> (Config.events_queue_auto_delete), default: <code>False</code>.</li> <li><code>EVENTS_QUEUE_PREFIX</code>, (Config.events_queue_prefix), default: <code>\"arrlio.\"</code>.</li> <li><code>EVENTS_TTL</code> (Config.events_ttl), default: <code>600</code>. <code>x-message-ttl</code> RabbitMQ option, seconds.</li> <li> <p><code>EVENTS_PREFETCH_COUNT</code> (Config.events_prefetch_count), default: <code>1</code>. RabbitMQ prefetch count options.</p> </li> <li> <p><code>RESULTS_QUEUE_MODE</code> (Config.results_queue_mode), default: <code>ResultQueueMode.COMMON</code>.</p> </li> <li><code>RESULTS_QUEUE_PREFIX</code> (COnfig.results_queue_prefix), default: <code>\"arrlio.\"</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p> <ul> <li><code>RESULTS_QUEUE_TYPE</code> (Config.results_queue_type), default: <code>QueueType.CLASSIC</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p> <ul> <li><code>RESULTS_QUEUE_DURABLE</code> (Config.results_queue_durable), default: <code>False</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p> <ul> <li><code>RESULTS_TTL</code> (Config.results_ttl), default: <code>600</code>. Result time to live, seconds.</li> <li><code>RESULTS_PREFETCH_COUNT</code> (Config.results_prefetch_count), default: <code>10</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p>"},{"location":"user_guide/basic/","title":"Basic","text":"<p>Define your tasks:</p> <pre><code>from arrlio import task\n\n@task\ndef hello_world():\n    print(\"Hello from Arrlio\")\n</code></pre> <p>Create application:</p> <pre><code>from arrlio import App, Config\n\napp = App(Config())\n</code></pre> <p>Info</p> <p>By default <code>local</code> backend will be used</p> <p>Start consuming tasks and run <code>hello_world</code> task:</p> <pre><code>async with app:\n    await app.consume_tasks()\n    await app.send_task(hello_world)\n</code></pre> <p>Summary:</p> main.py<pre><code>import asyncio\nfrom arrlio import App, Config, task\n\n@task\ndef hello_world():\n    print(\"Hello from Arrlio\")\n\n\nasync def main():\n    app = App(Config())\n    async with app:\n        await app.consume_tasks()\n        await app.send_task(hello_world)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>More examples can be found in the <code>examples</code> directory.</p>"},{"location":"user_guide/settings/","title":"Settings","text":"<p>Arrlio supports configuration from environment variables or from <code>Config</code> object. All environment varialbles should starts with <code>{ENV_PREFIX}</code>. Default value for <code>ENV_PREFIX</code> is <code>ARRLIO_</code>.</p>"},{"location":"user_guide/settings/#general","title":"General","text":"<ul> <li><code>APP_ID</code> (Config.app_id), default: <code>uuid4()</code>. Backend Id.</li> <li><code>TASK_QUEUES</code> (Config.task_queues), default: <code>[\"arrlio.tasks\"]</code>. List of the task queues to listen.</li> </ul>"},{"location":"user_guide/settings/#backend","title":"Backend","text":"<ul> <li><code>BACKEND_MODULE</code> (Config.backend.module), default: <code>\"arrlio.backends.local\"</code>. Backend module with <code>Backend</code> and <code>Config</code> classes.</li> <li><code>BACKEND_CONFIG</code> (Config.backend.config), default: <code>{}</code>. Config for backend.</li> </ul>"},{"location":"user_guide/settings/#task","title":"Task","text":"<ul> <li><code>TASK_QUEUE</code> (Config.task.queue), default: <code>\"arrlio.tasks\"</code>. Task queue.</li> <li><code>TASK_PRIORITY</code> (Conig.task.priority), default: <code>1</code>. Task priority. 0 - highest priority.</li> <li><code>TASK_TIMEOUT</code> (Config.task.timeout), default: <code>300</code>. Task execution timeout in seconds.</li> <li><code>TASK_TTL</code> (Config.task.ttl), default: <code>300</code>. Taks time to live in seconds.</li> <li><code>TASK_RESULT_RETURN</code> (Config.task.result_return), default: <code>True</code>. Return or not task result.</li> <li><code>TASK_RESULT_TTL</code> (Config.task.result_ttl), default: <code>300</code>. Task result time to live, seconds.</li> <li><code>TASK_EVENTS</code> (Config.task.events), default: <code>False</code>. Enable or disable task events.</li> <li><code>TASK_EVENT_TTL</code> (Config.task.event_ttl), default: <code>300</code>. Task event time to live in seconds.</li> </ul>"},{"location":"user_guide/settings/#event","title":"Event","text":"<ul> <li><code>EVENT_TTL</code> (Config.event.ttl), default: <code>300</code>. Event time to live in seconds.</li> </ul>"},{"location":"user_guide/settings/#plugins","title":"Plugins","text":"<ul> <li><code>PLUGINS</code> (Config.plugins), default: <code>[]</code>. List of plugins.</li> </ul>"},{"location":"user_guide/settings/#executor","title":"Executor","text":"<ul> <li><code>EXECUTOR_MODULE</code> (Config.executor.module), default: <code>arrlio.executor</code>. Executor module with <code>Config</code> and <code>Executor</code> classes.</li> <li><code>EXECUTOR_CONFIG</code> (Config.executor.config), default: <code>{}</code>. Config for executor.</li> </ul>"},{"location":"user_guide/settings/#example","title":"Example","text":"<pre><code>from arrlio import App, Config, BackendConfig, TaskConfig\n\nconfig = Config(\n    backend=BackendConfig(module=\"arrlio.backends.local\", config={\"id\": \"Test\"}),\n    task_queues=[\"tasks.default\", \"tasks.backend\", \"tasks.frontend\"],\n    ...\n    task=TaskConfig(\n        queue=\"tasks.default\",\n        ttl=None,\n        events=True,\n        ...\n    )\n)\n\napp = App(config)\n</code></pre>"},{"location":"user_guide/task_args/","title":"Task arguments","text":"<p>Positional arguments:</p> <pre><code>from arrlio import App, Config, task\n\n@task\ndef hello_world(name: str):\n    print(f\"Hello {name}\")\n\napp = App(Config())\nasync with app:\n    await app.consume_tasks()\n    await app.send_task(hello_world, args=(\"World\",))\n</code></pre> <p>Named arguments:</p> <pre><code>from arrlio import App, Config, task\n\n@task\ndef hello_world(name: str = None):\n    name = name or \"World\"\n    print(f\"Hello {name}\")\n\napp = App(Config())\nasync with app:\n    await app.consume_tasks()\n    await app.send_task(hello_world, kwds={\"name\": \"User\"})\n</code></pre>"},{"location":"user_guide/task_result/","title":"Task result","text":"<pre><code>from arrlio import App, Config, task\n\n@task\ndef add_one(x: int):\n    return x + 1\n\napp = App(Config())\nasync with app:\n    await app.consume_tasks()\n    ar = await app.send_task(add_one, args=(1,))\n    result = await ar.get()\n    print(f\"1 + 1 = {result}\")\n</code></pre>"},{"location":"user_guide/advanced/backend_configuration/","title":"Backend configuration","text":"<p>By default Arrlio use <code>local</code> backend. It is not useful for real usage.</p> <p>To choose a <code>rabbitmq</code> as backend specify application config as show below:</p> <pre><code>from arrlio import Config\n\nconfig = Config(module=\"arrlio.backends.rabbitmq\")\n</code></pre> <p>And for non default Backend configuration options:</p> <pre><code>from arrlio import Config\n\nconfig = Config(\n    module=\"arrlio.backends.rabbitmq\",\n    config={\n        \"url\": \"...\",\n        \"verify_ssl\": ...,\n        ...\n    },\n)\n</code></pre>"},{"location":"user_guide/advanced/generators/","title":"Generators","text":"<p>Arrlio supports generators:</p> <pre><code>from arrlio import App, Config, task\n\n@task\ndef xrange(x: int):\n    for i in range(x):\n        yield i\n\napp = App(Config())\nasync with app:\n    await app.consume_tasks()\n    ar = await app.send_task(xrange, args=(3,))\n    async for i in ar:\n        print(i)\n</code></pre> <p>Note</p> <p>For RabbitMQ backend this feature works only with <code>ResutsQueueMode.COMMON</code> mode.</p>"},{"location":"user_guide/advanced/task_submitting/","title":"Task submitting","text":"<p>Task can be invoked by task object or name and can have the following parameters:</p> <ul> <li><code>queue</code></li> <li><code>priority</code> from 1 to 10.</li> <li><code>timeout</code></li> <li><code>ttl</code></li> <li><code>result_return</code>. If <code>False</code> no result will be returned from the task.</li> <li><code>result_ttl</code></li> <li><code>thread</code>. If <code>True</code> task will be executed in a separate thread.</li> <li><code>events</code>. If <code>True</code> task events will be dispatched.</li> <li><code>extra</code></li> </ul> <p>Info</p> <p>These parameters passed in <code>send_task</code> method override task and application settings.</p> <pre><code>from arrlio import App, Config, task\n\n@task(name=\"Task foo\", priority=1, thread=False, events=False)\ndef foo():\n    return\n\napp = App(Config())\nasync with app:\n    await app.send_task(\n        foo,  # or \"Task foo\"\n        queue=\"tasks.foo\",\n        priority=5,\n        timeout=10,\n        ttl=60,\n        result_return=False,\n        thread=True,\n        events=True,\n        extra={\"key\": \"Additional extra info\"}\n    )\n</code></pre> <p>Info</p> <p>For <code>rabbitmq</code> backend Arrlio creates all needed exchanges and queues.</p>"}]}