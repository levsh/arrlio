{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Arrlio - distributed task system.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#arrlio.core","title":"<code>arrlio.core</code>","text":""},{"location":"api_reference/#arrlio.core.App","title":"<code>App</code>","text":"<p>Arrlio application.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>class App:\n\"\"\"Arrlio application.\"\"\"\ndef __init__(self, config: Config):\n\"\"\"\n        Args:\n            config: Arrlio application `arrlio.settings.Config`.\n        \"\"\"\nself.config = config\nself._backend = config.backend.module.Backend(config.backend.config)\nself._closed: asyncio.Future = asyncio.Future()\nself._running_tasks: Dict[UUID, asyncio.Task] = {}\nself._executor = config.executor.module.Executor(config.executor.config)\nself._context = ContextVar(\"context\", default={})\nself._hooks = {\n\"on_init\": [],\n\"on_close\": [],\n\"on_task_send\": [],\n\"on_task_received\": [],\n\"on_task_result\": [],\n\"on_task_done\": [],\n\"task_context\": [],\n}\nself._plugins = {}\nfor plugin_config in config.plugins:\nplugin = plugin_config.module.Plugin(self, plugin_config.config)\nself._plugins[plugin.name] = plugin\nfor k, hooks in self._hooks.items():\nif getattr(plugin, k).__func__ != getattr(Plugin, k):\nhooks.append(getattr(plugin, k))\nself._task_settings = {\nk: v\nfor k, v in config.task.dict(exclude_unset=True).items()\nif k in Task.__dataclass_fields__  # pylint: disable=no-member\n}\ndef __str__(self):\nreturn f\"{self.__class__.__name__}[{self._backend}]\"\ndef __repr__(self):\nreturn self.__str__()\nasync def __aenter__(self):\nawait self.init()\nreturn self\nasync def __aexit__(self, exc_type, exc, tb):\nawait self.close()\n@property\ndef hooks(self):\nreturn rodict(self._hooks, nested=True)\n@property\ndef plugins(self) -&gt; Dict[str, Plugin]:\n\"\"\"Application plugins.\"\"\"\nreturn rodict(self._plugins, nested=True)\n@property\ndef backend(self) -&gt; Backend:\n\"\"\"Application backend.\"\"\"\nreturn self._backend\n@property\ndef executor(self) -&gt; Executor:\n\"\"\"Application executor.\"\"\"\nreturn self._executor\n@property\ndef context(self):\nreturn self._context\n@property\ndef is_closed(self) -&gt; bool:\nreturn self._closed.done()\n@property\ndef task_settings(self) -&gt; dict:\nreturn self._task_settings\nasync def init(self):\n\"\"\"Init application and plugins.\"\"\"\nif self.is_closed:\nreturn\nlogger.info(\"%s: initializing with config\\n%s\", self, pretty_repr(self.config.dict()))\nawait self._execute_hooks(\"on_init\")\nlogger.info(\"%s: initialization done\", self)\nasync def close(self):\n\"\"\"Close application.\"\"\"\nif self.is_closed:\nreturn\ntry:\nawait self._execute_hooks(\"on_close\")\nfor hooks in self._hooks.values():\nhooks.clear()\nawait gather(\nself.stop_consume_tasks(),\nself.stop_consume_events(),\nreturn_exceptions=True,\n)\nawait self._backend.close()\nfor task_id, aio_task in tuple(self._running_tasks.items()):\nlogger.warning(\"%s: cancel processing task '%s'\", self, task_id)\naio_task.cancel()\ntry:\nawait aio_task\nexcept asyncio.CancelledError:\npass\nself._running_tasks = {}\nfinally:\nself._closed.set_result(None)\nasync def _execute_hook(self, hook_fn, *args, **kwds):\ntry:\nif is_debug_level():\nlogger.debug(\"%s: execute hook %s\", self, hook_fn)\nawait hook_fn(*args, **kwds)\nexcept Exception:\nlogger.exception(\"%s: hook %s error\", self, hook_fn)\nasync def _execute_hooks(self, hook: str, *args, **kwds):\nawait gather(*(self._execute_hook(hook_fn, *args, **kwds) for hook_fn in self._hooks[hook]))\nasync def send_task(\nself,\ntask: Union[Task, str],  # pylint: disable=redefined-outer-name\nargs: tuple = None,\nkwds: dict = None,\nextra: dict = None,\n**kwargs: dict,\n) -&gt; \"AsyncResult\":\n\"\"\"Send task.\n        Args:\n            task: `arrlio.models.Task` or task name.\n            args: Task args.\n            kwds: Task kwds.\n            extra: `arrlio.models.Task` extra argument.\n            kwargs: Other `arrlio.models.Task` other arguments.\n        Returns:\n            Task `arrlio.core.AsyncResult`.\n        \"\"\"\nname = task\nif isinstance(task, Task):\nname = task.name\nif extra is None:\nextra = {}\nextra[\"app_id\"] = self.config.app_id\nif name in registered_tasks:\ntask_instance = registered_tasks[name].instantiate(\nargs=args,\nkwds=kwds,\nextra=extra,\n**{**self._task_settings, **kwargs},\n)\nelse:\ntask_instance = Task(None, name).instantiate(\nargs=args,\nkwds=kwds,\nextra=extra,\n**{**self._task_settings, **kwargs},\n)\nif is_info_level():\nlogger.info(\n\"%s: send task instance\\n%s\",\nself,\npretty_repr(task_instance.dict(exclude=[\"args\", \"kwds\"])),\n)\nawait self._execute_hooks(\"on_task_send\", task_instance)\nawait self._backend.send_task(task_instance)\nreturn AsyncResult(self, task_instance)\nasync def send_event(self, event: Event):\nif is_info_level():\nlogger.info(\"%s: send event\\n%s\", self, pretty_repr(event.dict()))\nawait self._backend.send_event(event)\nasync def pop_result(self, task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]:\n# if not task_instance.data.result_return:\n#     raise TaskResultError(task_instance.data.task_id)\nasync for task_result in self._backend.pop_task_result(task_instance):\nif task_result.exc:\nif isinstance(task_result.exc, TaskError):\nraise task_result.exc\nraise TaskError(task_result.exc, task_result.trb)\nyield task_result.res\nasync def consume_tasks(self, queues: List[str] = None):\n\"\"\"Consume tasks from the queues.\"\"\"\nqueues = queues or self.config.task_queues\nif not queues:\nreturn\nasync def cb(task_instance: TaskInstance):\ntask_id: UUID = task_instance.task_id\nself._running_tasks[task_id] = current_task()\ntry:\nasync with AsyncExitStack() as stack:\nfor context in self._hooks[\"task_context\"]:\nawait stack.enter_async_context(context(task_instance))\nawait self._execute_hooks(\"on_task_received\", task_instance)\ntask_result: TaskResult = TaskResult()\nidx_0 = uuid4().hex\nidx_1 = 0\nasync for task_result in self.execute_task(task_instance):\nidx_1 += 1\ntask_result.set_idx([idx_0, idx_1])\nif task_instance.result_return:\nawait self._backend.push_task_result(task_instance, task_result)\nawait self._execute_hooks(\"on_task_result\", task_instance, task_result)\nif task_instance.result_return and not task_instance.extra.get(\"graph:graph\"):\nfunc = task_instance.func\nif isasyncgenfunction(func) or isgeneratorfunction(func):\nidx_1 += 1\nawait self._backend.close_task(task_instance, idx=(idx_0, idx_1))\nawait self._execute_hooks(\n\"on_task_done\",\ntask_instance,\n{\"exc\": task_result.exc, \"trb\": task_result.trb},\n)\nexcept asyncio.CancelledError:\nlogger.error(\"%s: task %s(%s) cancelled\", self, task_id, task_instance.name)\nraise\nexcept Exception as e:\nlogger.exception(e)\nfinally:\nself._running_tasks.pop(task_id, None)\nawait self._backend.consume_tasks(queues, cb)\nlogger.info(\"%s: consuming task queues %s\", self, queues)\nasync def stop_consume_tasks(self, queues: List[str] = None):\n\"\"\"Stop consuming tasks.\"\"\"\nawait self._backend.stop_consume_tasks(queues=queues)\nif queues is not None:\nlogger.info(\"%s: stop consuming task queues %s\", self, queues)\nelse:\nlogger.info(\"%s: stop consuming task queues\", self)\nasync def execute_task(self, task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]:\n\"\"\"Execute the task instance locally by the application executor.\"\"\"\nasync for task_result in self._executor(task_instance):\nyield task_result\nasync def consume_events(\nself,\ncallback_id: str,\ncallback: Union[Callable, AsyncFunction],\nevent_types: List[str] = None,\n):\n\"\"\"Consume events.\"\"\"\nawait self._backend.consume_events(callback_id, callback, event_types=event_types)\nasync def stop_consume_events(self, callback_id: str = None):\n\"\"\"Stop consuming events.\"\"\"\nawait self._backend.stop_consume_events(callback_id=callback_id)\ndef send_graph(self, *args, **kwds):\nif \"arrlio.graphs\" not in self.plugins:\nraise GraphError(\"Plugin required: allrio.graphs\")\nreturn self.plugins[\"arrlio.graphs\"].send_graph(*args, **kwds)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.plugins","title":"<code>plugins: Dict[str, Plugin]</code>  <code>property</code>","text":"<p>Application plugins.</p>"},{"location":"api_reference/#arrlio.core.App.backend","title":"<code>backend: Backend</code>  <code>property</code>","text":"<p>Application backend.</p>"},{"location":"api_reference/#arrlio.core.App.executor","title":"<code>executor: Executor</code>  <code>property</code>","text":"<p>Application executor.</p>"},{"location":"api_reference/#arrlio.core.App.__init__","title":"<code>__init__(config: Config)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Arrlio application <code>arrlio.settings.Config</code>.</p> required Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>def __init__(self, config: Config):\n\"\"\"\n    Args:\n        config: Arrlio application `arrlio.settings.Config`.\n    \"\"\"\nself.config = config\nself._backend = config.backend.module.Backend(config.backend.config)\nself._closed: asyncio.Future = asyncio.Future()\nself._running_tasks: Dict[UUID, asyncio.Task] = {}\nself._executor = config.executor.module.Executor(config.executor.config)\nself._context = ContextVar(\"context\", default={})\nself._hooks = {\n\"on_init\": [],\n\"on_close\": [],\n\"on_task_send\": [],\n\"on_task_received\": [],\n\"on_task_result\": [],\n\"on_task_done\": [],\n\"task_context\": [],\n}\nself._plugins = {}\nfor plugin_config in config.plugins:\nplugin = plugin_config.module.Plugin(self, plugin_config.config)\nself._plugins[plugin.name] = plugin\nfor k, hooks in self._hooks.items():\nif getattr(plugin, k).__func__ != getattr(Plugin, k):\nhooks.append(getattr(plugin, k))\nself._task_settings = {\nk: v\nfor k, v in config.task.dict(exclude_unset=True).items()\nif k in Task.__dataclass_fields__  # pylint: disable=no-member\n}\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.init","title":"<code>init()</code>  <code>async</code>","text":"<p>Init application and plugins.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def init(self):\n\"\"\"Init application and plugins.\"\"\"\nif self.is_closed:\nreturn\nlogger.info(\"%s: initializing with config\\n%s\", self, pretty_repr(self.config.dict()))\nawait self._execute_hooks(\"on_init\")\nlogger.info(\"%s: initialization done\", self)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close application.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def close(self):\n\"\"\"Close application.\"\"\"\nif self.is_closed:\nreturn\ntry:\nawait self._execute_hooks(\"on_close\")\nfor hooks in self._hooks.values():\nhooks.clear()\nawait gather(\nself.stop_consume_tasks(),\nself.stop_consume_events(),\nreturn_exceptions=True,\n)\nawait self._backend.close()\nfor task_id, aio_task in tuple(self._running_tasks.items()):\nlogger.warning(\"%s: cancel processing task '%s'\", self, task_id)\naio_task.cancel()\ntry:\nawait aio_task\nexcept asyncio.CancelledError:\npass\nself._running_tasks = {}\nfinally:\nself._closed.set_result(None)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.send_task","title":"<code>send_task(task: Union[Task, str], args: tuple = None, kwds: dict = None, extra: dict = None, **kwargs: dict) -&gt; AsyncResult</code>  <code>async</code>","text":"<p>Send task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Union[Task, str]</code> <p><code>arrlio.models.Task</code> or task name.</p> required <code>args</code> <code>tuple</code> <p>Task args.</p> <code>None</code> <code>kwds</code> <code>dict</code> <p>Task kwds.</p> <code>None</code> <code>extra</code> <code>dict</code> <p><code>arrlio.models.Task</code> extra argument.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>Other <code>arrlio.models.Task</code> other arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncResult</code> <p>Task <code>arrlio.core.AsyncResult</code>.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def send_task(\nself,\ntask: Union[Task, str],  # pylint: disable=redefined-outer-name\nargs: tuple = None,\nkwds: dict = None,\nextra: dict = None,\n**kwargs: dict,\n) -&gt; \"AsyncResult\":\n\"\"\"Send task.\n    Args:\n        task: `arrlio.models.Task` or task name.\n        args: Task args.\n        kwds: Task kwds.\n        extra: `arrlio.models.Task` extra argument.\n        kwargs: Other `arrlio.models.Task` other arguments.\n    Returns:\n        Task `arrlio.core.AsyncResult`.\n    \"\"\"\nname = task\nif isinstance(task, Task):\nname = task.name\nif extra is None:\nextra = {}\nextra[\"app_id\"] = self.config.app_id\nif name in registered_tasks:\ntask_instance = registered_tasks[name].instantiate(\nargs=args,\nkwds=kwds,\nextra=extra,\n**{**self._task_settings, **kwargs},\n)\nelse:\ntask_instance = Task(None, name).instantiate(\nargs=args,\nkwds=kwds,\nextra=extra,\n**{**self._task_settings, **kwargs},\n)\nif is_info_level():\nlogger.info(\n\"%s: send task instance\\n%s\",\nself,\npretty_repr(task_instance.dict(exclude=[\"args\", \"kwds\"])),\n)\nawait self._execute_hooks(\"on_task_send\", task_instance)\nawait self._backend.send_task(task_instance)\nreturn AsyncResult(self, task_instance)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.consume_tasks","title":"<code>consume_tasks(queues: List[str] = None)</code>  <code>async</code>","text":"<p>Consume tasks from the queues.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def consume_tasks(self, queues: List[str] = None):\n\"\"\"Consume tasks from the queues.\"\"\"\nqueues = queues or self.config.task_queues\nif not queues:\nreturn\nasync def cb(task_instance: TaskInstance):\ntask_id: UUID = task_instance.task_id\nself._running_tasks[task_id] = current_task()\ntry:\nasync with AsyncExitStack() as stack:\nfor context in self._hooks[\"task_context\"]:\nawait stack.enter_async_context(context(task_instance))\nawait self._execute_hooks(\"on_task_received\", task_instance)\ntask_result: TaskResult = TaskResult()\nidx_0 = uuid4().hex\nidx_1 = 0\nasync for task_result in self.execute_task(task_instance):\nidx_1 += 1\ntask_result.set_idx([idx_0, idx_1])\nif task_instance.result_return:\nawait self._backend.push_task_result(task_instance, task_result)\nawait self._execute_hooks(\"on_task_result\", task_instance, task_result)\nif task_instance.result_return and not task_instance.extra.get(\"graph:graph\"):\nfunc = task_instance.func\nif isasyncgenfunction(func) or isgeneratorfunction(func):\nidx_1 += 1\nawait self._backend.close_task(task_instance, idx=(idx_0, idx_1))\nawait self._execute_hooks(\n\"on_task_done\",\ntask_instance,\n{\"exc\": task_result.exc, \"trb\": task_result.trb},\n)\nexcept asyncio.CancelledError:\nlogger.error(\"%s: task %s(%s) cancelled\", self, task_id, task_instance.name)\nraise\nexcept Exception as e:\nlogger.exception(e)\nfinally:\nself._running_tasks.pop(task_id, None)\nawait self._backend.consume_tasks(queues, cb)\nlogger.info(\"%s: consuming task queues %s\", self, queues)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.stop_consume_tasks","title":"<code>stop_consume_tasks(queues: List[str] = None)</code>  <code>async</code>","text":"<p>Stop consuming tasks.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def stop_consume_tasks(self, queues: List[str] = None):\n\"\"\"Stop consuming tasks.\"\"\"\nawait self._backend.stop_consume_tasks(queues=queues)\nif queues is not None:\nlogger.info(\"%s: stop consuming task queues %s\", self, queues)\nelse:\nlogger.info(\"%s: stop consuming task queues\", self)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.execute_task","title":"<code>execute_task(task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]</code>  <code>async</code>","text":"<p>Execute the task instance locally by the application executor.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def execute_task(self, task_instance: TaskInstance) -&gt; AsyncGenerator[TaskResult, None]:\n\"\"\"Execute the task instance locally by the application executor.\"\"\"\nasync for task_result in self._executor(task_instance):\nyield task_result\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.consume_events","title":"<code>consume_events(callback_id: str, callback: Union[Callable, AsyncFunction], event_types: List[str] = None)</code>  <code>async</code>","text":"<p>Consume events.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def consume_events(\nself,\ncallback_id: str,\ncallback: Union[Callable, AsyncFunction],\nevent_types: List[str] = None,\n):\n\"\"\"Consume events.\"\"\"\nawait self._backend.consume_events(callback_id, callback, event_types=event_types)\n</code></pre>"},{"location":"api_reference/#arrlio.core.App.stop_consume_events","title":"<code>stop_consume_events(callback_id: str = None)</code>  <code>async</code>","text":"<p>Stop consuming events.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def stop_consume_events(self, callback_id: str = None):\n\"\"\"Stop consuming events.\"\"\"\nawait self._backend.stop_consume_events(callback_id=callback_id)\n</code></pre>"},{"location":"api_reference/#arrlio.core.AsyncResult","title":"<code>AsyncResult</code>","text":"Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>class AsyncResult:\n__slots__ = (\"_app\", \"_task_instance\", \"_gen\", \"_result\", \"_exception\", \"_ready\")\ndef __init__(self, app: App, task_instance: TaskInstance):\nself._app = app\nself._task_instance = task_instance\nself._gen = app.pop_result(task_instance)\nself._result: Any = None\nself._exception: Exception = None\nself._ready: bool = False\n@property\ndef task_instance(self) -&gt; TaskInstance:\n\"\"\"Task instance.\"\"\"\nreturn self._task_instance\n@property\ndef task_id(self):\n\"\"\"Task Id.\"\"\"\nreturn self._task_instance.task_id\n@property\ndef result(self):\n\"\"\"Task last result.\"\"\"\nreturn self._result\n@property\ndef exception(self) -&gt; Exception:\n\"\"\"Task exception.\"\"\"\nreturn self._exception\n@property\ndef ready(self) -&gt; bool:\n\"\"\"Task ready status.\"\"\"\nreturn self._ready\ndef __aiter__(self):\nreturn self\nasync def __anext__(self):\nif not self._ready:\ntry:\nself._result = await self._gen.__anext__()\nreturn self._result\nexcept TaskError as e:\nself._ready = True\nself._exception = e\nexcept StopAsyncIteration as e:\nself._ready = True\nraise e\nif exception := self._exception:\nif isinstance(exception.args[0], Exception):\nraise exception from exception.args[0]\nraise exception\nraise StopAsyncIteration\nasync def get(self) -&gt; Any:\n\"\"\"\n        Get task result. Blocking until the task result available.\n        For generator or asyncgenerator return the last available result.\n        \"\"\"\nnoresult = not self._ready\nasync for _ in self:\nnoresult = False\nif noresult:\nraise TaskClosedError(self.task_id)\nreturn self._result\n</code></pre>"},{"location":"api_reference/#arrlio.core.AsyncResult.task_instance","title":"<code>task_instance: TaskInstance</code>  <code>property</code>","text":"<p>Task instance.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.task_id","title":"<code>task_id</code>  <code>property</code>","text":"<p>Task Id.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.result","title":"<code>result</code>  <code>property</code>","text":"<p>Task last result.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.exception","title":"<code>exception: Exception</code>  <code>property</code>","text":"<p>Task exception.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.ready","title":"<code>ready: bool</code>  <code>property</code>","text":"<p>Task ready status.</p>"},{"location":"api_reference/#arrlio.core.AsyncResult.get","title":"<code>get() -&gt; Any</code>  <code>async</code>","text":"<p>Get task result. Blocking until the task result available. For generator or asyncgenerator return the last available result.</p> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>async def get(self) -&gt; Any:\n\"\"\"\n    Get task result. Blocking until the task result available.\n    For generator or asyncgenerator return the last available result.\n    \"\"\"\nnoresult = not self._ready\nasync for _ in self:\nnoresult = False\nif noresult:\nraise TaskClosedError(self.task_id)\nreturn self._result\n</code></pre>"},{"location":"api_reference/#arrlio.core.task","title":"<code>task(func: Union[FunctionType, MethodType, Type] = None, name: str = None, base: Type[Task] = None, **kwds: dict)</code>","text":"<p>Task decorator.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Union[FunctionType, MethodType, Type]</code> <p>Task function.</p> <code>None</code> <code>name</code> <code>str</code> <p>Task name.</p> <code>None</code> <code>base</code> <code>Type[Task]</code> <p>Task base class.</p> <code>None</code> <code>kwds</code> <code>dict</code> <p><code>arrlio.models.Task</code> arguments.</p> <code>{}</code> Source code in <code>/Users/levsh/workspace/dev/arrlio/arrlio/core.py</code> <pre><code>def task(func: Union[FunctionType, MethodType, Type] = None, name: str = None, base: Type[Task] = None, **kwds: dict):\n\"\"\"Task decorator.\n    Args:\n        func: Task function.\n        name: Task name.\n        base: Task base class.\n        kwds: `arrlio.models.Task` arguments.\n    \"\"\"\nif base is None:\nbase = Task\nif func is not None:\nif not isinstance(func, (FunctionType, MethodType)):\nraise TypeError(\"Argument 'func' does not a function or method\")\nif name is None:\nname = f\"{func.__module__}.{func.__name__}\"\nif name in registered_tasks:\nraise ValueError(f\"Task '{name}' already registered\")\nt = base(func=func, name=name, **kwds)\nregistered_tasks.__original__[name] = t\nlogger.debug(\"Register task '%s'\", t.name)\nreturn t\ndef wrapper(func):\nreturn task(base=base, func=func, name=name, **kwds)\nreturn wrapper\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install arrlio\n</code></pre>"},{"location":"user_guide/backends/","title":"Backends","text":"<p>Arrlio has several builtin backends:</p> <ul> <li>arrlio.backends.local</li> <li>arrlio.backends.rabbitmq</li> </ul>"},{"location":"user_guide/backends/#local","title":"Local","text":""},{"location":"user_guide/backends/#settings","title":"Settings","text":"<p>All environment varialbles should starts with <code>${ARRLIO_ENV_PREFIX}LOCAL_BACKEND_</code>.</p> <p>Info</p> <p>Default value for <code>ARRLIO_ENV_PREFIX</code> is <code>ARRLIO_</code>.</p> <ul> <li><code>ID</code> (Config.id), default: <code>\"arrlio\"</code>. Backend Id.</li> <li><code>SERIALIZER</code> (Config.serializer), default: <code>\"arrlio.serializers.nop\"</code>. Serializer module with <code>Serializer</code> and <code>Config</code> classes.</li> </ul>"},{"location":"user_guide/backends/#rabbitmq","title":"RabbitMQ","text":""},{"location":"user_guide/backends/#settings_1","title":"Settings","text":"<p>All environment varialbles should starts with <code>${ARRLIO_ENV_PREFIX}RMQ_BACKEND_</code>.</p> <ul> <li><code>ID</code> (Config.id), default: <code>uuid4()</code>. Backend Id.</li> <li><code>SERIALIZER</code> (Config.serializer), default: \"arrlio.serializers.json\". Serializer module with <code>Serializer</code> and <code>Config</code> classes.</li> <li><code>URL</code> (Config.url), default: <code>\"amqp://guest:guest@localhost\"</code>. RabbitMQ server url.</li> <li><code>VERIFY_SSL</code> (Config.verify_ssl), default: <code>True</code>.</li> <li><code>TIMEOUT</code> (Config.timeout), default: <code>10</code>. RabbitMQ operation timeout, seconds.</li> <li><code>PUSH_RETRY_TIMEOUTS</code> (Config.push_retry_timeouts), default: <code>[5, 5, 5, 5, 5]</code>. Retry timeout sequense for push operations, seconds.</li> <li> <p><code>PULL_RETRY_TIMEOUTS</code> (Config.pull_retry_timeouts), default: <code>itertools.repeat(5)</code>. Retry timeout sequense for pull operations, seconds.</p> </li> <li> <p><code>TASKS_EXCHANGE</code> (Config.tasks_exchange), default: <code>\"arrlio\"</code>. Tasks RabbitMQ exchange.</p> </li> <li><code>TASKS_EXCHANGE_DURABLE</code> (Config.tasks_exchange_durable), default: <code>False</code>.</li> <li><code>TASKS_QUEUE_TYPE</code> (Config.tasks_queue_type), default: <code>QueueType.CLASSIC</code>.</li> <li><code>TASKS_QUEUE_DURABLE</code> (Config.tasks_queue_durable), default: <code>False</code>.</li> <li><code>TASKS_QUEUE_AUTO_DELETE</code> (Config.tasks_queue_auto_delete), default: <code>True</code>.</li> <li><code>TASKS_QUEUE_TTL</code> (Config.tasks_queue_ttl), default: <code>None</code>. <code>x-message-ttl</code> RabbitMQ option, seconds.</li> <li> <p><code>TASKS_PREFETCH_COUNT</code> (Config.tasks_prefetch_count), default: <code>1</code>. RabbitMQ prefetch count options.</p> </li> <li> <p><code>EVENTS_EXCHANGE</code> (Config.events_exchange), default: <code>\"arrlio.events\"</code>. Events RabbitMQ exchange.</p> </li> <li><code>EVENTS_EXCHANGE_DURABLE</code> (Config.events_exchange_durable), default: <code>False</code>.</li> <li><code>EVENTS_QUEUE_TYPE</code> (Config.events_queue_type), default: <code>QueueType.CLASSIC</code>.</li> <li><code>EVENTS_QUEUE_DURABLE</code>, (Config.events_queue_durable), default: <code>False</code>.</li> <li><code>EVENTS_QUEUE_AUTO_DELETE</code> (Config.events_queue_auto_delete), default: <code>False</code>.</li> <li><code>EVENTS_QUEUE_PREFIX</code>, (Config.events_queue_prefix), default: <code>\"arrlio.\"</code>.</li> <li><code>EVENTS_TTL</code> (Config.events_ttl), default: <code>600</code>. <code>x-message-ttl</code> RabbitMQ option, seconds.</li> <li> <p><code>EVENTS_PREFETCH_COUNT</code> (Config.events_prefetch_count), default: <code>1</code>. RabbitMQ prefetch count options.</p> </li> <li> <p><code>RESULTS_QUEUE_MODE</code> (Config.results_queue_mode), default: <code>ResultQueueMode.COMMON</code>.</p> </li> <li><code>RESULTS_QUEUE_PREFIX</code> (COnfig.results_queue_prefix), default: <code>\"arrlio.\"</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p> <ul> <li><code>RESULTS_QUEUE_TYPE</code> (Config.results_queue_type), default: <code>QueueType.CLASSIC</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p> <ul> <li><code>RESULTS_QUEUE_DURABLE</code> (Config.results_queue_durable), default: <code>False</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p> <ul> <li><code>RESULTS_TTL</code> (Config.results_ttl), default: <code>600</code>. Result time to live, seconds.</li> <li><code>RESULTS_PREFETCH_COUNT</code> (Config.results_prefetch_count), default: <code>10</code>.</li> </ul> <p>Note</p> <p>Valid only with <code>ResultsQueueMode.COMMON</code>.</p>"},{"location":"user_guide/basic/","title":"Basic","text":"<p>Define your tasks:</p> <pre><code>from arrlio import task\n@task\ndef hello_world():\nprint(\"Hello from Arrlio\")\n</code></pre> <p>Create application:</p> <pre><code>from arrlio import App, Config\napp = App(Config())\n</code></pre> <p>Info</p> <p>By default <code>local</code> backend will be used</p> <p>Start consuming tasks and run <code>hello_world</code> task:</p> <pre><code>async with app:\nawait app.consume_tasks()\nawait app.send_task(hello_world)\n</code></pre> <p>Summary:</p> main.py<pre><code>import asyncio\nfrom arrlio import App, Config, task\n@task\ndef hello_world():\nprint(\"Hello from Arrlio\")\nasync def main():\napp = App(Config())\nasync with app:\nawait app.consume_tasks()\nawait app.send_task(hello_world)\nif __name__ == \"__main__\":\nasyncio.run(main())\n</code></pre> <p>More examples can be found in the <code>examples</code> directory.</p>"},{"location":"user_guide/settings/","title":"Settings","text":"<p>Arrlio supports configuration from environment variables or from <code>Config</code> object. All environment varialbles should starts with <code>{ENV_PREFIX}</code>. Default value for <code>ENV_PREFIX</code> is <code>ARRLIO_</code>.</p>"},{"location":"user_guide/settings/#general","title":"General","text":"<ul> <li><code>APP_ID</code> (Config.app_id), default: <code>uuid4()</code>. Backend Id.</li> <li><code>TASK_QUEUES</code> (Config.task_queues), default: <code>[\"arrlio.tasks\"]</code>. List of the task queues to listen.</li> </ul>"},{"location":"user_guide/settings/#backend","title":"Backend","text":"<ul> <li><code>BACKEND_MODULE</code> (Config.backend.module), default: <code>\"arrlio.backends.local\"</code>. Backend module with <code>Backend</code> and <code>Config</code> classes.</li> <li><code>BACKEND_CONFIG</code> (Config.backend.config), default: <code>{}</code>. Config for backend.</li> </ul>"},{"location":"user_guide/settings/#task","title":"Task","text":"<ul> <li><code>TASK_QUEUE</code> (Config.task.queue), default: <code>\"arrlio.tasks\"</code>. Task queue.</li> <li><code>TASK_PRIORITY</code> (Conig.task.priority), default: <code>1</code>. Task priority. 0 - highest priority.</li> <li><code>TASK_TIMEOUT</code> (Config.task.timeout), default: <code>300</code>. Task execution timeout in seconds.</li> <li><code>TASK_TTL</code> (Config.task.ttl), default: <code>300</code>. Taks time to live in seconds.</li> <li><code>TASK_RESULT_RETURN</code> (Config.task.result_return), default: <code>True</code>. Return or not task result.</li> <li><code>TASK_RESULT_TTL</code> (Config.task.result_ttl), default: <code>300</code>. Task result time to live, seconds.</li> <li><code>TASK_EVENTS</code> (Config.task.events), default: <code>False</code>. Enable or disable task events.</li> <li><code>TASK_EVENT_TTL</code> (Config.task.event_ttl), default: <code>300</code>. Task event time to live in seconds.</li> </ul>"},{"location":"user_guide/settings/#event","title":"Event","text":"<ul> <li><code>EVENT_TTL</code> (Config.event.ttl), default: <code>300</code>. Event time to live in seconds.</li> </ul>"},{"location":"user_guide/settings/#plugins","title":"Plugins","text":"<ul> <li><code>PLUGINS</code> (Config.plugins), default: <code>[]</code>. List of plugins.</li> </ul>"},{"location":"user_guide/settings/#executor","title":"Executor","text":"<ul> <li><code>EXECUTOR_MODULE</code> (Config.executor.module), default: <code>arrlio.executor</code>. Executor module with <code>Config</code> and <code>Executor</code> classes.</li> <li><code>EXECUTOR_CONFIG</code> (Config.executor.config), default: <code>{}</code>. Config for executor.</li> </ul>"},{"location":"user_guide/settings/#example","title":"Example","text":"<pre><code>from arrlio import App, Config, BackendConfig, TaskConfig\nconfig = Config(\nbackend=BackendConfig(module=\"arrlio.backends.local\", config={\"id\": \"Test\"}),\ntask_queues=[\"tasks.default\", \"tasks.backend\", \"tasks.frontend\"],\n...\ntask=TaskConfig(\nqueue=\"tasks.default\",\nttl=None,\nevents=True,\n...\n)\n)\napp = App(config)\n</code></pre>"},{"location":"user_guide/task_args/","title":"Task arguments","text":"<p>Positional arguments:</p> <pre><code>from arrlio import App, Config, task\n@task\ndef hello_world(name: str):\nprint(f\"Hello {name}\")\napp = App(Config())\nasync with app:\nawait app.consume_tasks()\nawait app.send_task(hello_world, args=(\"World\",))\n</code></pre> <p>Named arguments:</p> <pre><code>from arrlio import App, Config, task\n@task\ndef hello_world(name: str = None):\nname = name or \"World\"\nprint(f\"Hello {name}\")\napp = App(Config())\nasync with app:\nawait app.consume_tasks()\nawait app.send_task(hello_world, kwds={\"name\": \"User\"})\n</code></pre>"},{"location":"user_guide/task_result/","title":"Task result","text":"<pre><code>from arrlio import App, Config, task\n@task\ndef add_one(x: int):\nreturn x + 1\napp = App(Config())\nasync with app:\nawait app.consume_tasks()\nar = await app.send_task(add_one, args=(1,))\nresult = await ar.get()\nprint(f\"1 + 1 = {result}\")\n</code></pre>"},{"location":"user_guide/advanced/backend_configuration/","title":"Backend configuration","text":"<p>By default Arrlio use <code>local</code> backend. It is not useful for real usage.</p> <p>To choose a <code>rabbitmq</code> as backend specify application config as show below:</p> <pre><code>from arrlio import Config\nconfig = Config(module=\"arrlio.backends.rabbitmq\")\n</code></pre> <p>And for non default Backend configuration options:</p> <pre><code>from arrlio import Config\nconfig = Config(\nmodule=\"arrlio.backends.rabbitmq\",\nconfig={\n\"url\": \"...\",\n\"verify_ssl\": ...,\n...\n},\n)\n</code></pre>"},{"location":"user_guide/advanced/generators/","title":"Generators","text":"<p>Arrlio supports generators:</p> <pre><code>from arrlio import App, Config, task\n@task\ndef xrange(x: int):\nfor i in range(x):\nyield i\napp = App(Config())\nasync with app:\nawait app.consume_tasks()\nar = await app.send_task(xrange, args=(3,))\nasync for i in ar:\nprint(i)\n</code></pre> <p>Note</p> <p>For RabbitMQ backend this feature works only with <code>ResutsQueueMode.COMMON</code> mode.</p>"},{"location":"user_guide/advanced/task_submitting/","title":"Task submitting","text":"<p>Task can be invoked by task object or name and can have the following parameters:</p> <ul> <li><code>queue</code></li> <li><code>priority</code> from 1 to 10.</li> <li><code>timeout</code></li> <li><code>ttl</code></li> <li><code>result_return</code>. If <code>False</code> no result will be returned from the task.</li> <li><code>result_ttl</code></li> <li><code>thread</code>. If <code>True</code> task will be executed in a separate thread.</li> <li><code>events</code>. If <code>True</code> task events will be dispatched.</li> <li><code>extra</code></li> </ul> <p>Info</p> <p>These parameters passed in <code>send_task</code> method override task and application settings.</p> <pre><code>from arrlio import App, Config, task\n@task(name=\"Task foo\", priority=1, thread=False, events=False)\ndef foo():\nreturn\napp = App(Config())\nasync with app:\nawait app.send_task(\nfoo,  # or \"Task foo\"\nqueue=\"tasks.foo\",\npriority=5,\ntimeout=10,\nttl=60,\nresult_return=False,\nthread=True,\nevents=True,\nextra={\"key\": \"Additional extra info\"}\n)\n</code></pre> <p>Info</p> <p>For <code>rabbitmq</code> backend Arrlio creates all needed exchanges and queues.</p>"}]}